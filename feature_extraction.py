import fire
import os
import pandas as pd
import numpy as np
import re
import glob

import torch.nn as nn
import torch
from torch.utils.data import DataLoader
import torchvision.transforms as transforms

from data_loader import ImageDataset
import encoder_models.ResNet as resnet
import encoder_models.VGG as vgg


class FeatureExtractor:
    """


    """

    def __init__(self, imgs_path: str, model_name: str, img_type: str = 'png',
                 batch_size: int = 64):
        self.imgs_path = imgs_path
        self.model_name = model_name
        self.img_type = img_type

        self.batch_size = batch_size

    @property
    def model(self):
        # classifier is removed in the forward pass (see file in encoder_models)
        model_category = re.match('\D*', self.model_name).group(0)
        model_fct = eval(f'{model_category}.{self.model_name}')
        model = model_fct(pretrained=True)

        return model

    @property
    def transforms(self):
        return self.data.pre_process

    @property
    def data(self):
        return ImageDataset(root_dir=self.imgs_path, expected_input_size=self.model.expected_input_size, img_type=self.img_type)

    def get_features(self):
        dataloader = DataLoader(self.data, batch_size=self.batch_size, num_workers=0)
        features = {}
        for i_batch, (img_batch, filename_batch) in enumerate(dataloader):
            self.model.eval()
            # Forward Pass
            with torch.no_grad():
                output_batch = self.model(img_batch)
                # save the output features
                assert len(output_batch) == len(filename_batch)
                for fn, output in zip(list(filename_batch), output_batch):
                    features[fn] = np.array(output)

        return features


def extract_features(imgs_folder: str, output_path: str, model: str, multifolder: bool = False, img_type: str = 'png',
                     overwrite: bool = False):
    """
    This function creates a csv file with features generated by a forward pass through an ImageNet pre-trained network
    for given images.

    :param imgs_folder: string
        Path where the images are located. (also see multifolder argument to process multiple folders within a root folder)
    :param output_path: string
        Path where the feature csv file should be saved to.
    :param model: string
        Model name (e.g. resnet18). Check files in encoder_models to see what is available.
    :param multifolder: bool (optional)
        Default False. Set if the specified imgs_path contains multiple folders with images, that should all be processed.
    :param img_type: string (optional)
        Default is "png". Image type to look for.
    :param overwrite: bool (optional)
        Default is False. If set to True, existing files will be overwritten.
    """

    if not multifolder:
        subfolders = [imgs_folder]
    else:
        subfolders = [os.path.join(imgs_folder, o) for o in os.listdir(imgs_folder) if
                      os.path.isdir(os.path.join(imgs_folder, o))]

    for subfolder in subfolders:
        folder_name = os.path.basename(subfolder)
        csv_path = os.path.join(output_path, f'{folder_name}-{model}-patch-features.csv')

        if not os.path.isfile(csv_path) or overwrite:
            feature_extractor = FeatureExtractor(imgs_path=subfolder, model_name=model, img_type=img_type)
            features = feature_extractor.get_features()

            # create the data frame and save it
            df = pd.DataFrame.from_dict(features, orient='index')
            df.to_csv(csv_path)

    with open(os.path.join(output_path, 'transforms.txt'), 'w') as f:
        f.write(str(feature_extractor.transforms))


if __name__ == '__main__':
    fire.Fire(extract_features)
